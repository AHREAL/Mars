const str = '# Flow\n\n如何安装以及Flow的基本使用\n\n## 简介\n\n![image.png](/upload/1589387280014_0.4220.png)\n\n**Flow is a static type checker for JavaScript**\n\nhttps://flow.org/en/\n\nFaceBook开源的Javascript静态类型检查工具。\n\nFlow 是一个Javascript静态类型检查工具， 让你开发更加快速，智能，可靠，项目更加大型。\n\n他通过 **static type annotations** 对代码进行类型检查，你可以声明类型来来告诉Flow你的代码将如何进行工作，Flow会确保你的代码照着你规定的方式去运行。\n\n\n\n## 第一个例子\n\n在Flow中可以通过冒号的形式去规定变量的类型，在函数的参数括号后面规定函数的返回值类型\n\n```javascript\n// @flow\nfunction square(n: number): number { \n  return n * n;\n}\n\nsquare("2"); // Error!\n```\n\n\n\n## 使用Flow\n\n**安装**\n\n```shell\nnpm i flow-bin -D\n```\n\n**初始化flow配置文件**\n\n```shell\nnpx flow init\n```\n\n**头部添加**\n\n在需要进行类型检查的js文件头部添加\n\n```javascript\n// @flow\n```\n\n如果少了这个头部注释，则flow不会对文件进行类型检查。\n\n**我们有两种方式声明变量类型**\n\n1. 注释\n2. 直接改写\n\n**注释**\n\n```javascript\nvar a /*: number*/ = 10;\n```\n\n**直接改写（推荐）**\n\n```javascript\nvar a:number = 10;\n```\n\n如果直接改写js代码结构，则代码无法直接运行了，这时候便需要使用 **babel进行代码转换**\n\n**执行检查**\n\n```shell\nnpx flow \n```\n\n\n\n## 配合Babel\n\n通过上述第二种方式去使用FLow（直接改写），会导致js文件无法运行，这时候可以借助Babel对Js进行转码。\n\n**安装**\n\n```shell\nnpm i babel-cli babel-preset-flow -D\n```\n\n**创建.babelrc**\n\n```json\n{\n\t"presets":["flow"]\n}\n```\n\n**运行**\n\n```shell\nnpx babel ./src -d ./dist\n```\n\n\n\n这时候就可以看到，src目录下的flow代码已经被编译到dist目录下，并且可以顺利运行了。\n\n\n\n## Flow中的数据类型\n![image.png](/upload/1589387717500_0.0674.png)\n\n## 元素类型\n\n比如说Array数据类型较为特殊， 需要使用 <> 来声明数组中元素的类型\n\n```javascript\n// @flow\n\nlet arr: Array<number> = [1, 2, 3, 4]\n\nlet arr2: Array<number> = [1, 2, 3, \'4\']  //error\n\nlet arr3: Array<any> = [1, 2, 3, \'4\']\n```\n\n\n\n## 处理类型错误\n\n有了Flow以后， 我们可以十分方便的去规定数据的类型，之前我们没有Flow的情况下， 很多时候我们经常不知道我们什么时候应该进行类型判断，即使进行类型判断， 也十分的复杂和不便。\n\n**无Flow**\n\n```javascript\nconst count = (arr) => {\n    if(!arr){\n        throw new Error(\'参数不存在\') \n    }\n    \n    if(!Array.isArray(arr)){\n        thorw new Error(\'参数必须为一个数组\')\n    }\n    \n    if(!arr.every(item=>typeof item === \'number\')){\n        throw new Error(\'数组的元素必须为数字类型\')\n    }\n    // 前面的代码都是用来判断类型， 而真正的业务代码只有三行\n    \n    let sum\n    arr.forEach(item=> sum+=item)\n    return sum\n}\n```\n\n**使用Flow**\n\n```javascript\n// @flow\n\nconst count = (arr: Array<number>): number => {\n    // 类型事先声明， 则无需再进行类型判断， 代码简洁了许多\n    let sum: number = 0\n    arr.forEach(item=> sum+=item)\n    return sum\n}\n```\n\n\n\n## 函数类型\n\nFlow允许我们指定函数参数为函数的参数类型以及函数的返回值类型。\n\n听着有点绕😜\n\n假设我们定义了一个方法， 这个方法接收一个参数用作回调函数，我们可以规定这个回调函数的参数类型以及返回值类型。\n\n这儿有个例子，假设我们定义一个**sqlExec**方法， 函数接收两个参数， 一个是sql语句， 一个是回调函数用于接收sql查询的结果。\n\n**无Flow**\n\n```javascript\nconst sqlExec = async (sql, callBack) => {\n\tconst data = await query(sql)\n    callBack(data)\n}\n```\n\n**使用Flow**\n\n```javascript\n//@flow\n\nconst sqlExec = async (sql: string, callBack: (data: Object) => void):void => {\n    // 我们可以对CallBack的参数以及返回值进行类型检查\n    \n\tconst data = await query(sql)\n    callBack(data)\n}\n```\n\n\n\n## Maybe类型\n\n我们有时候需要实现函数的重载，在不使用**Maybe**类型时\n\n```javascript\n//@flow\n\n// 我们规定这个函数num默认值为1（如果调用者没有传递参数）\nconst fn = (num:number):number => {\n    num = num || 1\n    return num\n}\n\nfn() // error， 我们无法将undefined作为参数传递给fn\n```\n\n我们可以使用**Maybe**， 方式也很轻松， 加个问好\n\n```javascript\n//@flow\n\n// 我们规定这个函数num默认值为1（如果调用者没有传递参数）\nconst fn = (num:?number):number => {\n    num = num || 1\n    return num\n}\n\nfn() // 1\n```\n\n**Maybe**允许参数类型是规定好的(比如例子中是**number**)，或者是**undefined**，或者是**Null**\n\n\n\n## 或操作\n\n当一个变量具有多种允许的类型时， 我们可以使用 | 连接\n\n```javascript\n//@flow\n\nlet age: number|string = 10;\n\nage = "10";\n```\n\n\n\n## 类型推断\n\n在某些情况下我们没有声明完整类型，**Flow** 能够在一定程度上帮助我们进行类型的推断。\n\n```javascript\n//@flow\n\n// 我们没有声明fn返回值类型， 但是flow帮助我们推断出fn返回值类型为number\nconst fn = (a:number, b:number) => {\n    return a+b\n}\n\n// 我们将fn返回值赋值给c，c声明类型却为string。\nconst c:string = fn(1,2); //error\n```\n\n\n\n## 对象类型\n\n我们可以直接使用对象的花括号写法， 对对象的属性类型进行声明。\n\n```javascript\n//@flow\n\n// 假设我们存在一个ajax方法， ajax接收一个options，options需要有url, method, success回调\nconst ajax = (options: {url: string, method: string, success: (data:Object)=>void}) => {\n    \n}\n\najax() \n// error, 无法传递undefined个月ajax方法\n\najax({  \n    url:\'xxx\'\n})\n//error, method missing, success missing\n\najax({\n    url:\'xxx\',\n    method:\'GET\',\n    success:(data)=>{\n        \n    }\n})\n// no errors\n```';

export default str;
